# -*- coding: utf-8 -*-
"""
Created on Wed May  4 10:57:51 2016

@author: gazkune
"""

import sys, getopt
from ExpertActivityModel import ExpertActivityModel
from log_reader.Pattern import Pattern
from log_reader.Cluster import Cluster
from log_reader.LogReader import LogReader
from AD_pattern_filtering.ADPatternFilter import ADPatternFilter
import numpy as np
import pandas as pd
import json
import itertools
import time, datetime


class PatternModelMatching:
    
    """
    Constructor
    """    
    def __init__(self, eamsfile, annotatedfile, logfile, contextfile):
        self.eamsfile = eamsfile
        self.annotatedfile = annotatedfile
        self.logfile = logfile
        self.contextfile = contextfile
        self.contextmodel = json.loads(open(self.contextfile).read())        
        self.eamlist = []
        # We may not need to read the logfile and extract the pattern and cluster lists
        self.patternlist = []
        self.clusterlist = []
        # Attribute to store a dict of eam indices and all their possible combinations
        self.eamcombinations = {}        
    
    """  
    Method to load EAMs from the JSON file where they are defined
    """
    def loadEAMS(self):
        eamsdict = json.loads(open(self.eamsfile).read())
                
        for element in eamsdict:
            eam = ExpertActivityModel(element, eamsdict[element])            
            self.eamlist.append(eam)
            
        # For the maximization problem, build already all the combinations of EAM 
        # indices
        eamindex = range(0, len(self.eamlist))
        for i in eamindex:
            #eams = list(itertools.combinations(eamindex, i))
            self.eamcombinations[i] = list(itertools.combinations(eamindex, i+1))
            #print i
            #print self.eamcombinations[i]
            #print '-----------------------------------'
           
    """
    Method to load the annotated data csv file generated by AD into a pandas dataframe
    """
    def loadAnnotatedData(self):
        self.df = pd.read_csv(self.annotatedfile, parse_dates=[[0, 1]], header=None, index_col=0, sep='\t')        
        self.df.columns = ['sensor', 'action', 'event', 'pattern']
        self.df.index.names = ["timestamp"]
        
        # Load context model and transform sensor activations to actions        
        sensors = self.contextmodel["sensors"]        
        for i in self.df.index:        
            name_sensor = self.df.loc[i, "sensor"]
            try:
                action = sensors[name_sensor]["action"]
            except KeyError:
                msg = 'obtainActions: ' + name_sensor + ' sensor is not in the context_model; please have a look at provided dataset and context model'
                exit(msg)
            self.df.loc[i, "action"] = action
        
    """
    Method to store the detected EAMs in the internal dataframe as a new column (detected_activities)
    """
    def annotateDataFrame(self, start, end, bestnames):
        aux_df = self.df[start:end]
        for index in aux_df.index:
            self.df.loc[index, 'detected_activities'] = bestnames
            
    
    def prefilterPatterns(self):
        prefilter = ADPatternFilter(self.logfile)
        prefilter.filterPatterns()
        auxlist = ['Pat_%s' % (x.number) for x in prefilter.removedPatterns]
        
        for index in self.df.index:
            if self.df.loc[index, 'pattern'] in auxlist:
                self.df.loc[index, 'pattern'] = 'Other_Activity'
    
    """
    Method to iterate through the dataframe, extract patterns and calculate the suitability of EAMs for that
    pattern
    """
    def processPatterns(self):
        # TESTING!! Use the prefilter based
        self.prefilterPatterns()        
        # Filter all the actions tagged as Other_Activity
        auxdf = self.df[self.df["pattern"] != "Other_Activity"]
        actions = []
        pat = ""
        start = None
        end = None
        previous = None
        # Add a new column to self.df for the activities detected by the algorithm
        # The new column is initialized with 'None'
        detected_activities = [['None']]*len(self.df)
        self.df['detected_activities'] = detected_activities
        for timestamp in auxdf.index:
            if auxdf.loc[timestamp, "pattern"] != pat:
                if len(actions) > 0:
                    print 'New pattern'
                    print '   actions:', actions
                    end = previous
                    # Call here to the real matcher
                    # TODO: It seems there is a problem with the last pattern of the file. CHECK IT!!                    
                    [maxscore, bestnames, partialscores] = self.findModels4Pattern(actions, start, end)
                    # TESTING!! Action based filter  
                    if partialscores[0] == -1:
                        bestnames = ['None']
                        
                    # TESTING!! Number of activities greater than number of actions
                    if len(bestnames) > len(actions):
                        bestnames = ['None']                        
                    
                        
                    print '   start:', start, 'end:', end
                    print '   best eams:', bestnames, '(', maxscore, ')'
                    print '   partial scores: a(', partialscores[0], '), d(', partialscores[1], '), s(', partialscores[2], '), l(', partialscores[3], ')'
                    self.annotateDataFrame(start, end, bestnames)
                
                # Assign start the index value (the timestampt itself)
                start = timestamp
                #print 'New pattern!', auxdf.loc[timestamp, "pattern"]                
                pat = auxdf.loc[timestamp, "pattern"]
                actions = []
                
            actions.append(auxdf.loc[timestamp, "action"])
            previous = timestamp
            
    """
    Method to calculate for a given pattern (actions, start, end), the best list of EAMs
    to explain the pattern
    """
    def findModels4Pattern(self, actions, start, end):
        # define the weights of the cost function
        wa = 1        
        wl = 1
        wd = 0.2
        ws = 0.7
        #wt = 1
        # We will use a strong force search, testing all the posible combinations
        # of eams and returning the combination with the highest score
        maxscore = -sys.maxint
        partialscores = []
        bestnames = []
        for key in self.eamcombinations:
            # This is the list of EAM indices for combination level 'key' 
            eams = self.eamcombinations[key]
            for i in xrange(len(eams)):
                # Extract the EAM names of the current combination of EAMs
                names = [self.eamlist[j].name for j in eams[i]]
                #print '   ', names
                score_actions = self.funcActions(actions, eams[i])
                #score_time = self.funcTime(start, end, eams[i])
                score_duration = self.funcDuration(start, end, eams[i])
                score_start_time = self.funcStartTime(start, eams[i])
                score_locations = self.funcLocations(actions, eams[i])                
                
                score = wa*score_actions + wd*score_duration + ws*score_start_time + wl*score_locations                
                
                #print '   score:', score, 'SA:', score_actions, 'ST:', score_time
                if score > maxscore:
                    maxscore = score
                    bestnames = names
                    # store also the partial scores of each metric
                    partialscores = []
                    partialscores.append(score_actions)
                    partialscores.append(score_duration)
                    partialscores.append(score_start_time)
                    partialscores.append(score_locations)
                    
        return maxscore, bestnames, partialscores
            
    # The actions suitability function
    # TODO: the returned value is not between [0, 1], but between [-1, 1]
    def funcActions(self, actions, eamindices):
             
        eamactions = []        
        for i in eamindices:
            eamactions.extend(self.eamlist[i].actions)            
            
        eamactions = set(eamactions)        
        intersect = eamactions.intersection(actions)
        lactions = float(len(actions))
        lintersect = float(len(intersect))
        leams = float(len(eamactions))
        #score = float((len(intersect) / len(actions)) - ((len(eamactions) - len(intersect))/len(eamactions)))
        score = float((lintersect / lactions) - ((leams - lintersect)/leams))
        
        #print '   A: actions:', actions, 'eamactions:', eamactions, 
        #print '   ', len(actions), len(eamactions), len(intersect), score
        
        return score
    
    # The score function for the start of the pattern given the EAMs
    def funcStartTime(self, start, eamindices):
        start_p = datetime.datetime.strptime(start.strftime("%H:%M:%S"), "%H:%M:%S")
        # This list will store the highest score obtained by each of the EAMs
        eamscores = []
        for i in eamindices:
            ranges = self.eamlist[i].start
            # As an EAM may have several time ranges, partial scores will be calculated
            # and afterwards, the masimum score will be stored in eamscores
            partialscores = []
            for timerange in ranges:
                start_eam = timerange[0]
                end_eam = timerange[1]
                if start_p >= start_eam and start_p <= end_eam:
                    # The start time of the pattern is inside the range of the EAM
                    partialscores.append(1)
                elif start_p < start_eam:
                    # Apply a linear decreasing function where -1 is the minimum value
                    diff = start_eam - start_p
                    diff = diff.total_seconds()
                    k = 1.0
                    b = 0.1
                    partialscores.append(max(-1, k/diff - b))
                else:
                    # start_p > end_eam
                    # Apply a linear decreasing function where -1 is the minimum value
                    diff = start_p - end_eam
                    diff = diff.total_seconds()
                    k = 1.0
                    b = 0.1
                    partialscores.append(max(-1, k/diff - b))
            
            # We already have the partial scores for an EAM; keep only the maximum
            eamscores.append(max(partialscores))
            
        # At this point we have the best score for all EAMs in eamindices
        return sum(eamscores) / len(eamscores)
    
    # The score for the duration suitability of the pattern and the given EAMs    
    def funcDuration(self, start, end, eamindices):
        pat_duration = (end - start).total_seconds()
        eam_duration = 0
        for i in eamindices:
            eam_duration = eam_duration + self.eamlist[i].duration
            
        delta = abs(eam_duration - pat_duration)
        # delta stores the duration difference between the pattern and the EAMs
        k = 0.001
        score = max(-1, 1 - k*delta)
        return score
        
    # The time suitability function; start and end are timestamps for the pattern
    def funcTime(self, start, end, eamindices):
        # This list will store the highest score obtained by each of the EAMs
        eamscores = []
        # start and end are pandas timestamps with day, month and year info 
        # in order to calculate the difference, we need to get rid of year, month, day info
        start_p = datetime.datetime.strptime(start.strftime("%H:%M:%S"), "%H:%M:%S")
        end_p = datetime.datetime.strptime(end.strftime("%H:%M:%S"), "%H:%M:%S")
        #print '   start_p:', start_p, 'end_p:', end_p
        for i in eamindices:
            ranges = self.eamlist[i].start
            # As an EAM may have several time ranges, partial scores will be calculated
            # and afterwards, the masimum score will be stored in eamscores
            partialscores = []
            for timerange in ranges:
                start_eam = timerange[0]
                end_eam = timerange[1]
                #print '   start_eam:', start_eam, 'end_eam:', end_eam
                # Apply the equation for time suitability
                if start_eam < end_p:
                    # EAM is in the left hand side of the pattern
                    # Check whether there is any overlap
                    if end_eam < start_p:
                        partialscores.append(-1)
                    else:
                        # We have an overlap
                        # Take into account that we are operating with timestamps
                        # and datetime.timedelta
                        timedelta1 = end_p - start_eam
                        delta1 = timedelta1.total_seconds()
                        timedelta2 = end_eam - start_p
                        delta2 = timedelta2.total_seconds()
                        overlap = float(delta1) / float(delta2)
                        partialscores.append(min(1, 2*overlap - 1)) # overlap - (1 - overlap)
                else:
                    # The EAM is outside the pattern range (right)
                    partialscores.append(-1)
            
            # We already have the partial scores for an EAM; keep only the maximum
            eamscores.append(max(partialscores))
            
        # At this point we have the best score for all EAMs in eamindices
        return sum(eamscores) / len(eamscores)
         
    # The location suitability function     
    def funcLocations(self, actions, eamindices):
        return 0
        
    # Method to store the internal dataframe in a csv file
    def storeResult(self, filename):
        self.df.to_csv(filename)
            
    # Method to filter based on action metrics
    def filterWithActions(self, action_score):
        if action_score == -1:
            return True
        else:
            return False    
            
            
            
########################################################################################################################          
 
"""
Function to parse arguments from command line
Input:
    argv -> command line arguments
Output:
    inputfile -> log file generated by AD (custom format)

"""

def parseArgs(argv):
   eamsfile = ''
   annotatedfile = ''
   logfile = ''
   contextfile = ''
   outputfile = ''   
   
   try:
      opts, args = getopt.getopt(argv,"he:a:l:c:o:",["efile=", "afile=", "lfile=", "cfile=", "ofile="])
   except getopt.GetoptError:
      print 'PatternModelMatching.py -e <eamsfile> -a <annotatedfile> -l <logfile> -c <contextfile> -o <outputfile>'
      sys.exit(2)
   for opt, arg in opts:
      if opt == '-h':
         print 'PatternModelMatching.py -e <eamsfile> -a <annotatedfile> -l <logfile> -c <contextfile> -o <outputfile>'
         sys.exit()
      elif opt in ("-e", "--efile"):
         eamsfile = arg
      elif opt in ("-a", "--afile"):
         annotatedfile = arg
      elif opt in ("-l", "--lfile"):
         logfile = arg
      elif opt in ("-c", "--cfile"):
         contextfile = arg
      elif opt in ("-o", "--ofile"):
         outputfile = arg
         
   return eamsfile, annotatedfile, logfile, contextfile, outputfile
  
"""
Main function
"""
def main(argv):
    # call the argument parser 
   [eamsfile, annotatedfile, logfile, contextmodel, outputfile] = parseArgs(argv[1:])
   print 'Provided arguments:'       
   print eamsfile, annotatedfile, logfile, contextmodel
   
   matcher = PatternModelMatching(eamsfile, annotatedfile, logfile, contextmodel)
   matcher.loadEAMS()
   
   for eam in matcher.eamlist:
       eam.printEAM()
       print '-----------------------'
     
   matcher.loadAnnotatedData()
   #print matcher.df.head(50)
   matcher.processPatterns()
   matcher.storeResult(outputfile)
   
   
   
if __name__ == "__main__":
   main(sys.argv)